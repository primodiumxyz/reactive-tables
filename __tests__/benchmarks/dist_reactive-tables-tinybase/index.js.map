{"version":3,"sources":["../src/createWrapper.ts","../src/tables/createTableMethods.ts","../src/queries/templates/queryAllWithProperties.ts","../src/queries/templates/queryAllWithoutProperties.ts","../src/queries/templates/useAllWithProperties.ts","../src/queries/templates/useAllWithoutProperties.ts","../src/queries/createTableWatcher.ts","../src/queries/createTableTinyQLWatcher.ts","../src/queries/query.ts","../src/queries/$query.ts","../src/queries/useQuery.ts","../src/tables/contract/createRegistry.ts","../src/tables/contract/createMetadata.ts","../src/tables/contract/createTableKeyMethods.ts","../src/tables/local/createLocalTable.ts"],"sourcesContent":["import { storeToV1 } from \"@latticexyz/store/config/v2\";\nimport { resolveConfig } from \"@latticexyz/store/internal\";\n\nimport { type StorageAdapter, createStorageAdapter } from \"@/adapter\";\nimport { type ContractTables, createRegistry } from \"@/tables/contract\";\nimport {\n  type AllTableDefs,\n  createStore,\n  type ContractTableDefs,\n  type Store,\n  type StoreConfig,\n  storeTableDefs,\n  worldTableDefs,\n} from \"@/lib\";\n\n// (jsdocs)\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { createLocalTable } from \"@/tables/local\";\n\n/**\n * Defines the options for creating a TinyBase wrapper.\n *\n * @template config The type of the configuration object specifying tables definitions for contracts codegen.\n * @template extraTableDefs The types of any additional custom definitions to generate tables for.\n * @param mudConfig The actual MUD configuration, usually retrieved for the contracts package.\n * @param otherTableDefs (optional) Custom definitions to generate tables for as well.\n */\nexport type WrapperOptions<config extends StoreConfig, extraTableDefs extends ContractTableDefs | undefined> = {\n  mudConfig: config;\n  otherTableDefs?: extraTableDefs;\n};\n\n/**\n * The result of going through the TinyBase wrapper creation process.\n *\n * The registry is the main entry point to all kind of data retrieval and manipulation.\n *\n * @template config The type of the configuration object specifying tables definitions for contracts codegen.\n * @template tableDefs The types of the definitions used for generating tables.\n * @param registry The tables generated from all definitions (see {@link createRegistry}).\n * @param tableDefs The full definitions object, including provided MUD config and custom definitions, as well as store and world config tables.\n * @param store A wrapper around the TinyBase store, addressing either the \"regular\" or persistent store depending on the provided key,\n * as well as the queries instance (see {@link createStore}).\n * @param storageAdapter The storage adapter for formatting onchain logs into TinyBase tabular data (see {@link createStorageAdapter}).\n */\nexport type WrapperResult<config extends StoreConfig, extraTableDefs extends ContractTableDefs | undefined> = {\n  registry: ContractTables<AllTableDefs<config, extraTableDefs>>;\n  tableDefs: AllTableDefs<config, extraTableDefs>;\n  store: Store;\n  storageAdapter: StorageAdapter;\n};\n\n/**\n * This function creates a wrapper for transforming MUD tables and custom tables definitions into consumable\n * objects, while abstracting the infrastructure for communicating from onchain data (logs) to\n * easily manipulable and strictly typed tables & records. More specifically:\n * - encoding/decoding MUD and custom definitions into tabular data for TinyBase;\n * - encoding data from onchain logs into tabular data records for TinyBase;\n * - decoding data into TypeScript-friendly objects, and offering typed methods for access and manipulation;\n * - creating and reacting to queries, both in TinyBase queries and RECS-like formats.\n *\n * This is the main entry point into the library.\n *\n * Note: if the wrapper is used in a browser environment, and you intend to use persistent tables, you MUST wait for the\n * sync with local storage to be started; otherwise, there will be inconsistencies with properties from the last and current sessions.\n * See the example in the {@link createLocalTable} function for more information.\n *\n * @param options The {@link WrapperOptions} object specifying the MUD configuration and custom definitions.\n * @returns A {@link WrapperResult} object containing the tables, definitions, store, queries instance, and storage adapter.\n * @example\n * This example creates a wrapper from MUD config and sets the properties for a specific record in the \"Counter\" table.\n *\n * ```ts\n * const mudConfig = defineWorld({\n *   tables: {\n *     Counter: {\n *       schema: {\n *         value: \"uint32\",\n *       },\n *       key: [],\n *     },\n *   },\n * });\n *\n * const { registry } = createWrapper({ mudConfig });\n * registry.Counter.set({ value: 13 }); // fully typed\n * const properties = registry.Counter.get();\n * console.log(properties);\n * // -> { value: 13 }\n * ```\n * @category Creation\n */\nexport const createWrapper = <config extends StoreConfig, extraTableDefs extends ContractTableDefs | undefined>({\n  mudConfig,\n  otherTableDefs,\n}: WrapperOptions<config, extraTableDefs>): WrapperResult<config, extraTableDefs> => {\n  /* ------------------------------- DEFINITIONS ------------------------------ */\n  // Resolve tables definitions\n  const tableDefs = {\n    ...resolveConfig(storeToV1(mudConfig as StoreConfig)).tables,\n    ...(otherTableDefs ?? {}),\n    ...storeTableDefs,\n    ...worldTableDefs,\n  } as unknown as AllTableDefs<config, extraTableDefs>;\n\n  /* --------------------------------- TABLES --------------------------------- */\n  // Create the TinyBase store wrapper and queries instance\n  const store = createStore();\n  // Create tables registry from the definitions (format metadata, access/modify data using the store, perform queries)\n  const registry = createRegistry({ tableDefs, store: store(), queries: store().getQueries() });\n\n  /* ---------------------------------- SYNC ---------------------------------- */\n  // Create storage adapter (custom writer, see @primodiumxyz/sync-stack)\n  const storageAdapter = createStorageAdapter({ store });\n\n  return { registry, tableDefs, store, storageAdapter };\n};\n","import { useEffect, useState } from \"react\";\n\nimport { type Primitive, TinyBaseAdapter, type TinyBaseFormattedType } from \"@/adapter\";\nimport { createTableKeyMethods, type ContractTableMetadata } from \"@/tables/contract\";\nimport type { LocalTableMetadata } from \"@/tables/local\";\nimport type { Properties, PropertiesSansMetadata, CreateTableMethodsOptions } from \"@/tables\";\nimport {\n  type CreateTableWatcherOptions,\n  createTableWatcher,\n  queryAllWithProperties,\n  queryAllWithoutProperties,\n  type TableWatcherParams,\n  type TinyQLQueryKeywords,\n  useAllWithProperties,\n  useAllWithoutProperties,\n} from \"@/queries\";\nimport {\n  arrayToIterator,\n  createTableMethodsUtils,\n  default$Record,\n  type Metadata,\n  type $Record,\n  type Schema,\n  uuid,\n} from \"@/lib\";\n\nconst inContractTableMetadata = <S extends Schema, M extends Metadata>(\n  metadata: LocalTableMetadata<S, M> | ContractTableMetadata<S, M>,\n): metadata is ContractTableMetadata<S, M> => \"keySchema\" in metadata;\n\nexport const createTableMethods = <\n  S extends Schema,\n  M extends Metadata,\n  metadata extends LocalTableMetadata<S, M> | ContractTableMetadata<S, M>,\n  T = unknown,\n>({\n  store,\n  queries,\n  metadata,\n}: CreateTableMethodsOptions<S, M, metadata>) => {\n  const { tableId, schema } = metadata;\n  const { paused } = createTableMethodsUtils(store, tableId);\n\n  // Native RECS $records iterator\n  const $records = () => arrayToIterator(store.getRowIds(tableId) as $Record[]);\n\n  /* --------------------------------- STREAMS -------------------------------- */\n  // Pause updates for a record (don't react to changes in hooks, e.g. useProperties)\n  const pauseUpdates = ($record?: $Record, properties?: Properties<S, T>) => {\n    $record = $record ?? default$Record;\n\n    paused.set($record, true);\n    if (properties) set(properties, $record);\n  };\n\n  // Enable updates for a record (react again to changes in the store, e.g. useProperties)\n  // If any update happened during the pause, the state will be updated to the latest properties\n  const resumeUpdates = ($record?: $Record) => {\n    $record = $record ?? default$Record;\n\n    if (!paused.get($record)) return;\n    paused.set($record, false);\n  };\n\n  /* ----------------------------------- SET ---------------------------------- */\n  // Set the properties for a record\n  const set = (properties: Properties<S, T>, $record?: $Record) => {\n    $record = $record ?? default$Record;\n\n    // Encode the properties and set them in the store\n    const formattedProperties = TinyBaseAdapter.encode(properties as Record<string, Primitive>);\n    store.setRow(tableId, $record, formattedProperties);\n  };\n\n  // Utility function to save on computation when we want to set the formatted data directly\n  const setRaw = (properties: TinyBaseFormattedType, $record: $Record) => {\n    $record = $record ?? default$Record;\n    store.setRow(tableId, $record, properties);\n  };\n\n  /* ----------------------------------- GET ---------------------------------- */\n  // Get the properties for a record\n  function get(): Properties<S, T> | undefined;\n  function get($record: $Record | undefined): Properties<S, T> | undefined;\n  function get($record?: $Record | undefined, defaultProperties?: PropertiesSansMetadata<S, T>): Properties<S, T>;\n  function get($record?: $Record, defaultProperties?: PropertiesSansMetadata<S, T>) {\n    $record = $record ?? default$Record;\n    const row = store.getRow(tableId, $record);\n\n    const decoded = Object.entries(row).length > 0 ? TinyBaseAdapter.decode(row) : undefined; // empty object should be undefined\n    return (decoded ?? defaultProperties) as Properties<S, T>;\n  }\n\n  // Utility function to save on computation when we're only interested in the raw data (to set again directly)\n  const getRaw = ($record: $Record) => {\n    const row = store.getRow(tableId, $record);\n    return Object.entries(row).length > 0 ? row : undefined;\n  };\n\n  /* --------------------------------- QUERIES -------------------------------- */\n  // Get all records inside the table\n  const getAll = () => {\n    return store.getRowIds(tableId) as $Record[];\n  };\n\n  // Get all records with specific properties\n  const getAllWith = (properties: Partial<Properties<S, T>>) => {\n    return queryAllWithProperties({ queries, tableId, properties }).$records;\n  };\n\n  // Get all records without specific properties\n  const getAllWithout = (properties: Partial<Properties<S, T>>) => {\n    return queryAllWithoutProperties({ queries, tableId, properties }).$records;\n  };\n\n  /* ---------------------------------- HOOKS --------------------------------- */\n  // Hook to get all records inside the table\n  function useAll() {\n    const [$records, set$Records] = useState<$Record[]>(getAll());\n\n    useEffect(() => {\n      // Whenever a record is added or removed (row ids changed), update the state\n      const subId = store.addRowIdsListener(tableId, () => {\n        set$Records(getAll());\n      });\n\n      return () => {\n        store.delListener(subId);\n      };\n    }, []);\n\n    return $records;\n  }\n\n  // Hook to get all records with specific properties\n  const useAllWith = (properties: Partial<Properties<S, T>>) => {\n    return useAllWithProperties(queries, tableId, properties);\n  };\n\n  // Hook to get all records without specific properties\n  const useAllWithout = (properties: Partial<Properties<S, T>>) => {\n    return useAllWithoutProperties(queries, tableId, properties);\n  };\n\n  /* ---------------------------------- CLEAR --------------------------------- */\n  // Clear the table (remove all records)\n  const clear = () => {\n    store.delTable(tableId);\n  };\n\n  /* --------------------------------- REMOVE --------------------------------- */\n  // Remove a record from the table (delete its properties)\n  const remove = ($record?: $Record) => {\n    $record = $record ?? default$Record;\n    store.delRow(tableId, $record);\n  };\n\n  /* --------------------------------- UPDATE --------------------------------- */\n  // Update the properties for a record, possibly with partial properties\n  const update = (properties: Partial<Properties<S, T>>, $record?: $Record) => {\n    $record = $record ?? default$Record;\n    const currentProperties = getRaw($record);\n    if (!currentProperties) throw new Error(`$Record ${$record} does not exist in table ${tableId}`);\n\n    const newProperties = TinyBaseAdapter.encode(properties as Record<string, Primitive>);\n    setRaw({ ...currentProperties, ...newProperties }, $record);\n  };\n\n  /* ----------------------------------- HAS ---------------------------------- */\n  // Check if a record exists in the table\n  const has = ($record?: $Record) => {\n    if (!$record) return false;\n    return store.hasRow(tableId, $record);\n  };\n\n  /* ----------------------------- USE PROPERTIES ----------------------------- */\n  // Hook to get the properties for a record in real-time\n  function useProperties($record?: $Record | undefined): Properties<S, T> | undefined;\n  function useProperties(\n    $record: $Record | undefined,\n    defaultProperties?: PropertiesSansMetadata<S, T>,\n  ): Properties<S, T>;\n  function useProperties($record?: $Record, defaultProperties?: PropertiesSansMetadata<S, T>) {\n    $record = $record ?? default$Record;\n    const [properties, setProperties] = useState(get($record));\n\n    useEffect(() => {\n      // properties just changed for this record, update state to latest properties\n      // (just make sure this one is not paused)\n      if (!paused.get($record)) {\n        setProperties(get($record));\n      }\n\n      // Update state when the properties for this $record changes\n      const propertiesSubId = store.addRowListener(tableId, $record, () => {\n        // only if it's not paused\n        if (!paused.get($record)) {\n          setProperties(get($record));\n        }\n      });\n\n      // Update state when updates are unpaused\n      const pausedSubId = store.addValueListener(`paused__${tableId}__${$record}`, (_, __, newPaused) => {\n        // Meaning updates are being resumed\n        if (!newPaused) {\n          setProperties(get($record));\n        }\n      });\n\n      return () => {\n        store.delListener(propertiesSubId);\n        store.delListener(pausedSubId);\n      };\n    }, [$record, paused]);\n\n    return properties ?? defaultProperties;\n  }\n\n  /* ---------------------------------- QUERY --------------------------------- */\n  // Query the table using TinyQL syntax\n  const query = (definition: (keywords: TinyQLQueryKeywords) => void) => {\n    // Add a `select` on top of the query to abstract selecting at least a cell from the properties => selecting all $records\n    // This is required with TinyQL to at least select a cell so it considers all rows\n    const abstractedQuery = (keywords: TinyQLQueryKeywords) => {\n      keywords.select(Object.keys(schema)[0]);\n      definition(keywords);\n    };\n\n    // Define and run the query\n    const queryId = uuid();\n    queries.setQueryDefinition(queryId, tableId, abstractedQuery);\n    const result = queries.getResultRowIds(queryId);\n\n    queries.delQueryDefinition(queryId);\n    return result as $Record[];\n  };\n\n  /* ---------------------------------- WATCH --------------------------------- */\n  // Create a query tied to this table, with callbacks on change, enter & exit from the query conditions\n  // or if no query, on any change in the table\n  const watch = (\n    options: Omit<CreateTableWatcherOptions<S, T>, \"queries\" | \"tableId\" | \"schema\">,\n    params?: TableWatcherParams,\n  ) => {\n    // Same abstraction as in `query` to select all $records\n    const query: CreateTableWatcherOptions<S, T>[\"query\"] = options.query\n      ? (keywords) => {\n          keywords.select(Object.keys(schema)[0]);\n          options.query!(keywords);\n        }\n      : undefined;\n\n    return createTableWatcher(\n      {\n        queries,\n        tableId,\n        schema,\n        ...options,\n        query,\n      },\n      params,\n    );\n  };\n\n  // Base methods available to all tables\n  const baseMethods = {\n    $records,\n    get,\n    set,\n    getAll,\n    getAllWith,\n    getAllWithout,\n    remove,\n    clear,\n    update,\n    has,\n    pauseUpdates,\n    resumeUpdates,\n    query,\n    watch,\n  };\n\n  // Add hooks only if not in a node environment\n  const hookMethods = { useAll, useAllWith, useAllWithout, use: useProperties };\n  if (typeof window === \"undefined\") {\n    Object.keys(hookMethods).forEach((key) => {\n      hookMethods[key as keyof typeof hookMethods] = () => {\n        throw new Error(`The method ${key} is only available in the browser`);\n      };\n    });\n  }\n\n  const methods = {\n    ...baseMethods,\n    ...hookMethods,\n  };\n  // If it's a local table, no need for contract methods\n  if (!inContractTableMetadata(metadata)) return methods;\n\n  return {\n    ...methods,\n    ...createTableKeyMethods({ ...methods, keySchema: metadata.keySchema }),\n  };\n};\n","import { type Primitive, TinyBaseAdapter } from \"@/adapter\";\nimport type { TableQueryOptions, TableQueryResult } from \"@/queries\";\nimport type { ContractTableDef, $Record } from \"@/lib\";\n\n// Query all records for a given table that have specific properties (or partial properties)\nexport const queryAllWithProperties = <tableDef extends ContractTableDef>({\n  queries,\n  tableId,\n  properties,\n  formattedProperties,\n}: TableQueryOptions<tableDef>): TableQueryResult => {\n  const queryId = \"internal__queryAllWithProperties\";\n\n  // Format the properties for TinyBase storage to compare it with the stored properties\n  formattedProperties = formattedProperties ?? TinyBaseAdapter.encode(properties as Record<string, Primitive>);\n\n  queries.setQueryDefinition(queryId, tableId, ({ select, where }) => {\n    // Select the first cell as all records with a properties should have this cell\n    select(Object.keys(properties)[0]);\n\n    // Keep records which for each given key in the properties\n    Object.keys(properties).forEach((key) => {\n      // has an equal property in the table (where behaves like an AND operator for each key)\n      where(key, formattedProperties[key]);\n    });\n  });\n\n  const $records: $Record[] = [];\n  // Retrieve all ids of the rows matching the query (records)\n  queries.forEachResultRow(queryId, (rowId) => $records.push(rowId as $Record));\n\n  return { id: queryId, $records };\n};\n","import { type Primitive, TinyBaseAdapter } from \"@/adapter\";\nimport type { TableQueryOptions, TableQueryResult } from \"@/queries\";\nimport type { ContractTableDef, $Record } from \"@/lib\";\n\n// Query all records for a given table that DON'T have specific properties (or partial properties)\nexport const queryAllWithoutProperties = <tableDef extends ContractTableDef>({\n  queries,\n  tableId,\n  properties,\n  formattedProperties,\n}: TableQueryOptions<tableDef>): TableQueryResult => {\n  const queryId = \"internal__queryAllWithoutProperties\";\n\n  // Format the properties for TinyBase storage to compare it with the stored ones\n  formattedProperties = formattedProperties ?? TinyBaseAdapter.encode(properties as Record<string, Primitive>);\n\n  queries.setQueryDefinition(queryId, tableId, ({ select, where }) => {\n    // We need to make one select for the row to be included\n    // It should in any case contain any of the keys if the record is in the table\n    // So we select the first key (all records)\n    select(Object.keys(properties)[0]);\n\n    // Where at least one of the properties is different\n    where((getCell) => Object.keys(properties).some((key) => getCell(key) !== formattedProperties[key]));\n  });\n\n  const $records: $Record[] = [];\n  // Retrieve all ids of the rows matching the query (records)\n  queries.forEachResultRow(queryId, (rowId) => $records.push(rowId as $Record));\n  // queries.delQueryDefinition(\"queryAllWithoutProperties\");\n\n  return { id: queryId, $records };\n};\n","import { useEffect, useMemo, useState } from \"react\";\n\nimport { type Primitive, TinyBaseAdapter } from \"@/adapter\";\nimport { queryAllWithProperties } from \"@/queries/templates/queryAllWithProperties\";\nimport type { TableQueryOptions } from \"@/queries\";\nimport type { ContractTableDef, $Record, TinyBaseQueries } from \"@/lib\";\n\n// Listen to all records inside a given table that have specific properties (or partial properties)\nexport const useAllWithProperties = <tableDef extends ContractTableDef>(\n  queries: TinyBaseQueries,\n  tableId: string,\n  properties: TableQueryOptions<tableDef>[\"properties\"],\n): $Record[] => {\n  // Format the properties for TinyBase storage to compare it with the stored ones\n  const formattedProperties = useMemo(\n    () => TinyBaseAdapter.encode(properties as Record<string, Primitive>),\n    [properties],\n  );\n  const [$records, set$Records] = useState<$Record[]>([]);\n\n  useEffect(() => {\n    // Get the id and perform the initial query\n    const { id, $records } = queryAllWithProperties({ queries, tableId, properties, formattedProperties });\n    set$Records($records);\n\n    // Setup the listener for the query\n    const listenerId = queries.addResultRowIdsListener(id, () => {\n      // Update with the records that match the query\n      set$Records(queries.getResultRowIds(id) as $Record[]);\n    });\n\n    return () => {\n      queries.delListener(listenerId);\n    };\n  }, [queries, formattedProperties]);\n\n  return $records;\n};\n","import { useEffect, useMemo, useState } from \"react\";\n\nimport { type Primitive, TinyBaseAdapter } from \"@/adapter\";\nimport { queryAllWithoutProperties } from \"@/queries/templates/queryAllWithoutProperties\";\nimport type { TableQueryOptions } from \"@/queries\";\nimport type { ContractTableDef, $Record, TinyBaseQueries } from \"@/lib\";\n\n// Listen to all records inside a given table that DON'T have specific properties (or a single property)\nexport const useAllWithoutProperties = <tableDef extends ContractTableDef>(\n  queries: TinyBaseQueries,\n  tableId: string,\n  properties: TableQueryOptions<tableDef>[\"properties\"],\n): $Record[] => {\n  // Format the properties for TinyBase storage to compare it with the stored properties\n  const formattedProperties = useMemo(\n    () => TinyBaseAdapter.encode(properties as Record<string, Primitive>),\n    [properties],\n  );\n  const [$records, set$Records] = useState<$Record[]>([]);\n\n  useEffect(() => {\n    // Get the id and perform the initial query\n    const { id, $records } = queryAllWithoutProperties({ queries, tableId, properties, formattedProperties });\n    set$Records($records);\n\n    // Setup the listener for the query\n    const listenerId = queries.addResultRowIdsListener(id, () => {\n      // Update with the records that match the query\n      set$Records(queries.getResultRowIds(id) as $Record[]);\n    });\n\n    return () => {\n      queries.delListener(listenerId);\n    };\n  }, [queries, formattedProperties]);\n\n  return $records;\n};\n","import { TinyBaseAdapter } from \"@/adapter\";\nimport { createTableTinyQLWatcher } from \"@/queries\";\nimport type {\n  CreateTableWatcherOptions,\n  CreateTableWatcherResult,\n  TableUpdate,\n  TableWatcherParams,\n  UpdateType,\n} from \"@/queries\";\nimport type { Properties } from \"@/tables\";\nimport { type Schema, type $Record, uuid, getPropertiesAndTypeFromRowChange } from \"@/lib\";\n\n/**\n * Create a watcher/listener for a table, either globally (on all changes) or within a TinyQL query.\n * This will listen to changes in the table (potentially only within the query) and trigger callbacks when records enter, exit, or change.\n *\n * Note: This function is directly provided as a table method, when using `table.watch()`.\n * Which abstracts a few parameters like `queries`, `tableId` and `schema`.\n *\n * Note: Refer to {@link createTableTinyQLWatcher} for the behavior when a TinyQL query is provided.\n *\n * @param options The options for creating the table watcher.\n * - `queries` The TinyBase queries object tied to the store containing properties for all records inside this table (abstracted).\n * - `tableId` The id of the table to watch for changes (abstracted).\n * - `schema` The schema of the properties for all records inside this table (abstracted).\n * - `onChange` Callback triggered on any change in the table/query (encompassing enter, exit, and update).\n * - `onEnter` Callback triggered when a record enters the table/query (`properties.prev` will be undefined).\n * - `onExit` Callback triggered when a record exits the table/query (`properties.current` will be undefined).\n * - `onUpdate` Callback triggered when the properties of a record are updated (within the query if provided).\n * @param params Additional parameters for the watcher.\n * - `runOnInit` Whether to trigger the callbacks for all records on initialization (default: `true`).\n * @returns An object with an `unsubscribe` method to stop listening to the table.\n * @example\n * This example creates a watcher for all records within (with properties inside) the \"Player\" table.\n *\n * ```ts\n * const { registry, store } = createWrapper({ mudConfig });\n * const playerRecord = getPlayerRecord(); // for the sake of the example\n * registry.Player.set({ health: 100 }, playerRecord);\n *\n * // The function should be accessed from the table's methods\n * const { unsubscribe } = registry.Player.watch({\n *   onChange: (update) => console.log(update),\n * }, {\n *   runOnInit: false,\n * });\n * // no output\n *\n * registry.Player.update({ health: 90 }, playerRecord);\n * // -> { table: registry.Player, $record: playerRecord, current: { health: 90 }, prev: { health: 100 }, type: \"change\" }\n *\n * registry.Player.remove(playerRecord);\n * // -> { table: registry.Player, $record: playerRecord, current: undefined, prev: { health: 90 }, type: \"exit\" }\n *\n * // Unsubscribe from the watcher once you're done or when disposing of the component\n * unsubscribe();\n * ```\n * @see {@link createTableTinyQLWatcher} for an example with a TinyQL query.\n * @see TinyQL for writing a query: https://tinybase.org/guides/making-queries/tinyql/\n * @category Queries\n * @internal\n */\nexport const createTableWatcher = <S extends Schema, T = unknown>(\n  options: CreateTableWatcherOptions<S, T>,\n  params: TableWatcherParams = { runOnInit: true },\n): CreateTableWatcherResult => {\n  const {\n    queries,\n    query, // leave empty to listen to the whole table\n    tableId,\n    schema,\n    onChange,\n    onEnter,\n    onExit,\n    onUpdate,\n  } = options;\n  // If a query is provided, define it and create the listener\n  if (query) {\n    const queryId = uuid();\n    queries.setQueryDefinition(queryId, tableId, query);\n    return createTableTinyQLWatcher({ queries, queryId, tableId, schema, onChange, onEnter, onExit }, params);\n  }\n\n  if (!onChange && !onEnter && !onExit && !onUpdate) {\n    throw new Error(\"At least one callback has to be provided\");\n  }\n\n  // If not, just listen to the whole table\n  const store = queries.getStore();\n  // Get the keys to be able to aggregate the full properties from each cell\n  const keys = Object.keys(schema);\n\n  // This will be triggered on any change to a row/cell (meaning all properties or just a single one)\n  const listenerId = store.addRowListener(tableId, null, (_, __, rowId, getCellChange) => {\n    // If `getCellChange` is undefined, it means that `store.callListener()` was called\n    if (!getCellChange) return;\n    const $record = rowId as $Record;\n\n    // Gather the properties and type of the change\n    const args = getPropertiesAndTypeFromRowChange(getCellChange, keys, tableId, $record) as TableUpdate<S, T>;\n\n    // Run the callbacks\n    if (args.type === \"enter\") {\n      onEnter?.(args);\n    } else if (args.type === \"exit\") {\n      onExit?.(args);\n    } else {\n      onUpdate?.(args);\n    }\n\n    onChange?.(args);\n  });\n\n  if (params.runOnInit) {\n    const rows = store.getTable(tableId);\n\n    // Run callbacks for all records in the query\n    Object.entries(rows).forEach(([rowId, rowContent]) => {\n      const currentProperties = TinyBaseAdapter.decode(rowContent) as Properties<S, T>;\n\n      const args = {\n        tableId,\n        $record: rowId as $Record,\n        properties: { current: currentProperties, prev: undefined },\n        type: \"enter\" as UpdateType,\n      };\n      onEnter?.(args);\n      onChange?.(args);\n    });\n  }\n\n  return {\n    unsubscribe: () => store.delListener(listenerId),\n  };\n};\n","import type { Properties } from \"@/tables\";\nimport { TinyBaseAdapter } from \"@/adapter\";\nimport type { CreateQueryWatcherOptions, TableUpdate, TableWatcherParams, UpdateType } from \"@/queries\";\nimport { getPropertiesAndTypeFromRowChange, type $Record, type Schema } from \"@/lib\";\n\n// (jsdocs)\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { createTableWatcher } from \"./createTableWatcher\";\n\n/**\n * Creates a watcher for a specific TinyQL query inside a table.\n * This will listen to changes in the query and trigger callbacks when records enter, exit, or change.\n *\n * Note: This function is directly provided as a table method, when using `table.watch()` and filling the `query` parameter.\n * Which abstracts a few parameters like `queries`, `queryId`, `tableId` and `schema` (the `queryId` is generated when defining the provided query).\n *\n * Note: Refer to {@link createTableWatcher} for the behavior when no query is provided.\n *\n * @param options The options for creating the query watcher.\n * - `queries` The TinyBase queries object tied to the store containing properties for all records inside this table (abstracted).\n * - `queryId` The id of the query to watch after it's been defined internally (abstracted).\n * - `tableId` The id of the table to watch for changes (abstracted).\n * - `schema` The schema of the properties for all records inside this table (abstracted).\n * - `onChange` Callback triggered on any change in the query (encompassing enter, exit, and update).\n * - `onEnter` Callback triggered when a record enters the query (`properties.prev` will be undefined).\n * - `onExit` Callback triggered when a record exits the query (`properties.current` will be undefined).\n * - `onUpdate` Callback triggered when the properties of a record are updated, but it stays within the query.\n * @param params Additional parameters for the watcher.\n * - `runOnInit` Whether to trigger the callbacks for all matching records on initialization (default: `true`).\n * @returns An object with an `unsubscribe` method to stop listening to the query.\n * @example\n * This example creates a watcher for all records with more than 10 points in the \"Score\" table.\n *\n * ```ts\n * const { registry, store } = createWrapper({ mudConfig });\n * registry.Score.set({ points: 10 }, recordA);\n *\n * // The function should be accessed from the table's methods\n * const { unsubscribe } = registry.Score.watch({\n *   onChange: (update) => console.log(update),\n *   // if `query` is not provided, it will watch for any change in the table\n *   query: ({ where }) => {\n *     where((getCell) => (getCell(\"points\") as number) > 10);\n *   },\n * });\n * // -> { table: registry.Score, $record: recordA, current: { points: 10 }, prev: undefined, type: \"enter\" }\n *\n * registry.Score.update({ points: 15 }, recordA);\n * // -> { table: registry.Score, $record: recordA, current: { points: 15 }, prev: { points: 10 }, type: \"change\" }\n *\n * registry.Score.update({ points: 5 }, recordA);\n * // -> { table: registry.Score, $record: recordA, current: undefined, prev: { points: 15 }, type: \"exit\" }\n *\n * // Unsubscribe from the query once you're done or when disposing of the component\n * unsubscribe();\n * ```\n * @see TinyQL for writing a query: https://tinybase.org/guides/making-queries/tinyql/\n * @category Queries\n * @internal\n */\nexport const createTableTinyQLWatcher = <S extends Schema, T = unknown>(\n  options: CreateQueryWatcherOptions<S, T>,\n  params: TableWatcherParams = { runOnInit: true },\n) => {\n  const { queries, queryId, tableId, schema, onChange, onEnter, onExit, onUpdate } = options;\n  if (!onChange && !onEnter && !onExit && !onUpdate) {\n    throw new Error(\"At least one callback has to be provided\");\n  }\n\n  const store = queries.getStore();\n  // Get the keys to be able to aggregate the full properties from each cell\n  const keys = Object.keys(schema);\n\n  // Remember the previous records matching the query to figure out if it's an enter or an exit\n  // This is a trick we need because we can't listen to entire row changes within the query when only some cells have changed\n  let previous$Records: $Record[] = [];\n\n  // Init listener\n  // Unfortunatly `addResultRowListener()` won't work here as it's not triggered for cell changes\n  // So we need to use a regular listener associated with the query instead\n  const listenerId = store.addRowListener(tableId, null, (_, __, rowId, getCellChange) => {\n    if (!getCellChange) return;\n    const $record = rowId as $Record;\n\n    // Get the records matching the query\n    const matching$Records = queries.getResultRowIds(queryId);\n\n    // Figure out if it's an enter or an exit\n    let type = \"change\" as UpdateType;\n    const inPrev = previous$Records.includes($record);\n    const inCurrent = matching$Records.includes($record);\n\n    if (!inPrev && !inCurrent) return; // not in the query, we're not interested\n\n    // Gather the previous and current properties\n    const args = getPropertiesAndTypeFromRowChange(getCellChange, keys, tableId, $record) as TableUpdate<S, T>;\n\n    // Run the callbacks\n    if (!inPrev && inCurrent) {\n      type = \"enter\";\n      onEnter?.({ ...args, type });\n\n      previous$Records.push($record);\n    } else if (inPrev && !inCurrent) {\n      type = \"exit\";\n      onExit?.({ ...args, type });\n\n      previous$Records = previous$Records.filter((e) => e !== $record);\n    } else {\n      onUpdate?.({ ...args, type });\n    }\n\n    onChange?.({ ...args, type });\n  });\n\n  if (params.runOnInit) {\n    const rows = store.getTable(tableId);\n\n    // Run callbacks for all records in the query\n    queries.forEachResultRow(queryId, ($record) => {\n      const currentProperties = TinyBaseAdapter.decode(rows[$record]) as Properties<S, T>;\n\n      const args = {\n        tableId,\n        $record: $record as $Record,\n        properties: { current: currentProperties, prev: undefined },\n        type: \"enter\" as UpdateType,\n      };\n      onEnter?.(args);\n      onChange?.(args);\n\n      previous$Records.push($record as $Record);\n    });\n  }\n\n  return {\n    unsubscribe: () => queries.delListener(listenerId),\n  };\n};\n","import { createQueries } from \"tinybase/queries\";\n\nimport { queryAllWithProperties } from \"@/queries/templates/queryAllWithProperties\";\nimport type { QueryOptions } from \"@/queries\";\nimport type { ContractTableDef, $Record, Store } from \"@/lib\";\n\n/**\n * Queries all records matching multiple provided conditions across tables.\n *\n * Note: See {@link QueryOptions} for more details on conditions criteria.\n *\n * @param store The TinyBase store containing the properties associated with contract tables.\n * @param options The {@link QueryOptions} object containing the conditions to match.\n * @returns An array of {@link $Record} objects matching all conditions.\n * @example\n * This example queries all records that have a score of 10 in the \"Score\" table and are not inside the \"GameOver\" table.\n *\n * ```ts\n * const { registry, store } = createWrapper({ mudConfig });\n * registry.Score.set({ points: 10 }, recordA);\n * registry.Score.set({ points: 10 }, recordB);\n * registry.Score.set({ points: 3 }, recordC);\n * registry.GameOver.set({ value: true }, recordB);\n *\n * const records = query(store, {\n *   withProperties: [{ table: registry.Score, properties: { points: 10 } }],\n *   without: [registry.GameOver],\n * });\n * console.log(records);\n * // -> [ recordA ]\n * ```\n * @category Queries\n */\nexport const query = <tableDefs extends ContractTableDef[], T = unknown>(\n  _store: Store,\n  options: QueryOptions<tableDefs, T>,\n): $Record[] => {\n  const {\n    with: inside,\n    without: notInside,\n    withProperties: withProperties,\n    withoutProperties: withoutProperties,\n  } = options;\n  if (!inside && !withProperties) {\n    throw new Error(\"At least one inside or with condition needs to be provided\");\n  }\n  const store = _store();\n  const queries = createQueries(store);\n\n  /* --------------------------------- INSIDE --------------------------------- */\n  // Start with records inside all inside tables\n  let $records = inside\n    ? inside.reduce<$Record[]>((acc, table, index) => {\n        return (\n          table\n            // get all records inside this table\n            .getAll()\n            // keep them if they were inside previous tables as well\n            .filter(($record) => (index !== 0 ? acc.includes($record) : true))\n        );\n      }, [])\n    : [];\n\n  /* ---------------------------------- WITH ---------------------------------- */\n  // Keep records with all given properties (or init if no previous condition was given)\n  withProperties?.forEach(({ table, properties }, i) => {\n    const { id: queryId, $records: $recordsWithProperties } = queryAllWithProperties({\n      queries,\n      tableId: table.id,\n      properties,\n    });\n    // If no previous condition was given, init with the first table's records\n    if (inside === undefined && i === 0) {\n      $records = $recordsWithProperties;\n      if (i === withProperties.length - 1) queries.delQueryDefinition(queryId);\n      return;\n    }\n    // If inside was given (or already iterated once), find out if among records with the given properties there are\n    // $records that are already matching previous conditions\n    $records = $recordsWithProperties.filter(($record) => $records.includes($record));\n\n    // Remove query definition on the last iteration\n    if (i === withProperties.length - 1) queries.delQueryDefinition(queryId);\n  });\n\n  /* ------------------------------- NOT INSIDE ------------------------------- */\n  // Remove $records not inside any notInside table\n  notInside?.forEach((table) => {\n    // TODO: what is quicker: getAll() in table then filter out, or table.has() (underlying store.hasRow())\n    $records = $records.filter(($record) => !table.has($record));\n  });\n\n  /* -------------------------------- WITHOUT --------------------------------- */\n  // Remove records with any of the given propertiess\n  withoutProperties?.forEach(({ table, properties }, i) => {\n    // we could use queryAllWithoutPropertiess but it seems more likely that this below will return less records to iterate over\n    const { id: queryId, $records: $recordsWithProperties } = queryAllWithProperties({\n      queries,\n      tableId: table.id,\n      properties,\n    });\n    $records = $records.filter(($record) => !$recordsWithProperties.includes($record));\n\n    if (i === withoutProperties.length - 1) queries.delQueryDefinition(queryId);\n  });\n\n  return $records;\n};\n","import { query } from \"@/queries\";\nimport type { QueryOptions, TableWatcherCallbacks, TableUpdate, TableWatcherParams, UpdateType } from \"@/queries\";\nimport { getPropertiesAndTypeFromRowChange } from \"@/lib\";\nimport type { ContractTableDef, $Record, Schema, Store } from \"@/lib\";\n\n/**\n * Listen to all records matching multiple conditions across tables.\n *\n * This will trigger the provided callbacks whenever a record enters or exits the query conditions, or when its properties change\n * within the query conditions.\n *\n * Note: This is related to ${@link query} (direct retrieval based on conditions) and ${@link useQuery} (React hook inside callbacks + real-time retrieval).\n *\n * Note: See {@link QueryOptions} for more details on conditions criteria.\n *\n * @param store The TinyBase store containing the properties associated inside contract tables.\n * @param queryOptions The {@link QueryOptions} object containing the conditions to match.\n * @param callbacks The {@link TableWatcherCallbacks} to trigger on changes. Including: onChange, onEnter, onExit, onUpdate.\n * These will trigger a {@link TableUpdate} object inside the id of the updated table, the record, the previous and new properties of the record and the type of update.\n * @param options (optional) Additional options for the query. Currently only supports `runOnInit` to trigger the callbacks for all matching records on initialization.\n * @returns An object inside an `unsubscribe` method to stop listening to the query.\n * @example\n * This example creates a query that listens to all records that represent online players notInside a score of 0.\n *\n * ```ts\n * const { registry, store } = createWrapper({ mudConfig });\n * registry.Player.set({ score: 10, online: true }, recordA);\n * registry.Player.set({ score: 0, online: true }, recordB);\n * registry.Player.set({ score: 10, online: false }, recordC);\n *\n * const { unsubscribe } = $query(store, {\n *   withProperties: [{ table: registry.Player, properties: { online: true } }],\n *   withoutProperties: [{ table: registry.Player, properties: { score: 0 } }],\n * }, {\n *  onEnter: (update) => console.log(update),\n *  onExit: (update) => console.log(update),\n * }, { runOnInit: true }); // this is the default behavior\n * // -> { table: undefined, $record: recordA, current: undefined, prev: undefined, type: \"enter\" }\n *\n * registry.Player.update({ score: 15 }, recordA);\n * // -> { table: registry.Player, $record: recordA, current: { online: true, score: 15 }, prev: { online: true, score: 10 }, type: \"change\" }\n *\n * registry.Player.update({ online: false }, recordA);\n * // -> { table: registry.Player, $record: recordA, current: { online: false, score: 15 }, prev: { online: true, score: 15 }, type: \"change\" }\n *\n * // Unsubscribe from the query once you're done or when disposing of the component\n * unsubscribe();\n * ```\n * @category Queries\n */\nexport const $query = <tableDefs extends ContractTableDef[], S extends Schema, T = unknown>(\n  _store: Store,\n  queryOptions: QueryOptions<tableDefs, T>,\n  callbacks: TableWatcherCallbacks<S, T>,\n  params: TableWatcherParams = { runOnInit: true },\n) => {\n  const { onChange, onEnter, onExit, onUpdate } = callbacks;\n  if (!onChange && !onEnter && !onExit && !onUpdate) {\n    throw new Error(\"At least one callback has to be provided\");\n  }\n\n  const store = _store();\n  // Remember previous records (to provide the update type in the callback)\n  let prev$Records: $Record[] = [];\n\n  // Gather ids and schemas of all table we need to listen to\n  // tableId => schema keys\n  const tables: Record<string, string[]> = {};\n  const { with: inside, without: notInside, withProperties, withoutProperties } = queryOptions;\n\n  (inside ?? []).concat(notInside ?? []).forEach((table) => {\n    tables[table.id] = Object.keys(table.schema);\n  });\n  (withProperties ?? []).concat(withoutProperties ?? []).forEach(({ table }) => {\n    tables[table.id] = Object.keys(table.schema);\n  });\n\n  // Listen to all tables (at each row)\n  const listenerId = store.addRowListener(null, null, (_, tableId, rowId, getCellChange) => {\n    if (!getCellChange) return;\n    const $record = rowId as $Record;\n\n    // Refetch matching records if one of the tables included in the query changes\n    if (Object.keys(tables).includes(tableId)) {\n      const matching$Records = query(_store, queryOptions);\n\n      // Figure out if it's an enter or an exit\n      let type = \"change\" as UpdateType;\n      const inPrev = prev$Records.includes($record);\n      const inCurrent = matching$Records.includes($record);\n\n      if (!inPrev && !inCurrent) return; // not in the query, we're not interested\n\n      // Gather the previous and current properties\n      const args = getPropertiesAndTypeFromRowChange(getCellChange, tables[tableId], tableId, $record) as TableUpdate<\n        S,\n        T\n      >;\n\n      // Run the callbacks\n      if (!inPrev && inCurrent) {\n        type = \"enter\";\n        onEnter?.({ ...args, type });\n\n        prev$Records.push($record);\n      } else if (inPrev && !inCurrent) {\n        type = \"exit\";\n        onExit?.({ ...args, type });\n\n        prev$Records = prev$Records.filter((e) => e !== $record);\n      } else {\n        onUpdate?.({ ...args, type });\n      }\n\n      onChange?.({ ...args, type });\n    }\n  });\n\n  if (params.runOnInit) {\n    const matching$Records = query(_store, queryOptions);\n\n    // Run callbacks for all records in the query\n    matching$Records.forEach(($record) => {\n      const args = {\n        tableId: undefined,\n        $record,\n        properties: { current: undefined, prev: undefined },\n        type: \"enter\" as UpdateType,\n      };\n      onEnter?.(args);\n      onChange?.(args);\n\n      prev$Records.push($record);\n    });\n  }\n\n  return {\n    unsubscribe: () => store.delListener(listenerId),\n  };\n};\n","import { useEffect, useMemo, useRef, useState } from \"react\";\n\nimport { query } from \"@/queries\";\nimport type { QueryOptions, TableWatcherCallbacks, TableUpdate, UpdateType } from \"@/queries\";\nimport { getPropertiesAndTypeFromRowChange } from \"@/lib\";\nimport type { ContractTableDef, $Record, Schema, Store } from \"@/lib\";\n\n// TODO: this will clearly need to be optimized; there are probably a few options:\n// - setup a table listener by default on each table, then when setting up a query listener let that table know so it adds this callback to its array\n// - keep a single useQuery listening to all tables, then on change see across all actual useQuery hooks which ones need to be triggered\n\n/**\n * React hook to query all records matching multiple conditions across tables.\n *\n * This will return an array of $Record objects matching all conditions, and will trigger the provided callbacks on changes.\n *\n * Note: See {@link QueryOptions} for more details on conditions criteria.\n *\n * Note: This hook will only trigger on changes after it's mounted, not on creation for all initial matching records.\n *\n * @param store The TinyBase store containing the properties associated with contract tables.\n * @param options The {@link QueryOptions} object containing the conditions to match.\n * @param callbacks (optional) The {@link TableWatcherCallbacks} to trigger on changes. Including: onChange, onEnter, onExit, onUpdate.\n * These will trigger a {@link TableUpdate} object with the id of the updated table, the record, the previous and new properties of the record and the type of update.\n * @returns An array of {@link $Record} matching all conditions.\n * @example\n * This example queries all records that have a score of 10 in the \"Score\" table and are not inside the \"GameOver\" table.\n *\n * ```ts\n * const { registry, store } = createWrapper({ mudConfig });\n * registry.Score.set({ points: 10 }, recordA);\n * registry.Score.set({ points: 10 }, recordB);\n * registry.Score.set({ points: 3 }, recordC);\n * registry.GameOver.set({ value: true }, recordB);\n *\n * const records = useQuery(store, {\n *   withProperties: [ { table: registry.Score, properties: { points: 10 } } ],\n *   without: [ registry.GameOver ],\n * }, {\n *   onChange: (update) => console.log(update),\n * });\n * console.log(records);\n * // -> [ recordA ]\n *\n * registry.Score.update({ points: 10 }, recordC);\n * // -> { table: registry.Score, $record: recordC, current: { points: 10 }, prev: { points: 3 }, type: \"change\" }\n * console.log(records);\n * // -> [ recordA, recordC ]\n * ```\n * @category Queries\n */\nexport const useQuery = <tableDefs extends ContractTableDef[], S extends Schema, T = unknown>(\n  _store: Store,\n  options: QueryOptions<tableDefs, T>,\n  callbacks?: TableWatcherCallbacks<S, T>,\n): $Record[] => {\n  // Not available in a non-browser environment\n  if (typeof window === \"undefined\") throw new Error(\"useQuery is only available in a browser environment\");\n  const { onChange, onEnter, onExit, onUpdate } = callbacks ?? {};\n  const store = _store();\n\n  const [$records, set$Records] = useState<$Record[]>([]);\n  // Create a ref for previous records (to provide the update type in the callback)\n  const prev$Records = useRef<$Record[]>([]);\n\n  // Gather ids and schemas of all table we need to listen to\n  // tableId => schema keys\n  const tables = useMemo(() => {\n    const { with: inside, without: notInside, withProperties, withoutProperties } = options;\n    const tables: Record<string, string[]> = {};\n\n    (inside ?? []).concat(notInside ?? []).forEach((table) => {\n      tables[table.id] = Object.keys(table.schema);\n    });\n    (withProperties ?? []).concat(withoutProperties ?? []).forEach(({ table }) => {\n      tables[table.id] = Object.keys(table.schema);\n    });\n\n    return tables;\n  }, [options]);\n\n  useEffect(() => {\n    // Initial query\n    const curr$Records = query(_store, options);\n    set$Records(curr$Records);\n    prev$Records.current = curr$Records;\n\n    // Listen to all tables (at each row)\n    const listenerId = store.addRowListener(null, null, (_, tableId, $recordKey, getCellChange) => {\n      if (!getCellChange) return;\n      const $record = $recordKey as $Record;\n\n      // Refetch matching $records if one of the tables included in the query changes\n      if (Object.keys(tables).includes(tableId)) {\n        const new$Records = query(_store, options);\n\n        // Figure out if it's an enter or an exit\n        let type = \"change\" as UpdateType;\n        const inPrev = prev$Records.current.includes($record);\n        const inCurrent = new$Records.includes($record);\n\n        // Gather the previous and current properties\n        const args = getPropertiesAndTypeFromRowChange(getCellChange, tables[tableId], tableId, $record) as TableUpdate<\n          S,\n          T\n        >;\n\n        // Run the callbacks\n        if (!inPrev && inCurrent) {\n          type = \"enter\";\n          onEnter?.({ ...args, type });\n        } else if (inPrev && !inCurrent) {\n          type = \"exit\";\n          onExit?.({ ...args, type });\n        } else {\n          onUpdate?.({ ...args, type });\n        }\n\n        onChange?.({ ...args, type });\n\n        // Update ref and state\n        set$Records(new$Records);\n        prev$Records.current = new$Records;\n      }\n    });\n\n    return () => {\n      store.delListener(listenerId);\n    };\n  }, []);\n\n  return $records;\n};\n","import { createMetadata, type ContractTables } from \"@/tables/contract\";\nimport { createTableMethods, type CreateContractTablesOptions } from \"@/tables\";\nimport { type ContractTableDefs, mapObject, type StoreConfig, storePropertiesSchema } from \"@/lib\";\n\n/**\n * Creates a registry of contract tables with both their metadata (see {@link createMetadata}) and methods to retrieve/update\n * properties (see {@link createTableMethods}).\n *\n * @param tableDefs The contract table definitions.\n * @param store The regular TinyBase store.\n * @param queries The TinyBase queries object associated with the store.\n * @returns The contract tables registry.\n * @category Tables\n * @internal\n */\nexport const createRegistry = <config extends StoreConfig, extraTableDefs extends ContractTableDefs | undefined>({\n  tableDefs,\n  store,\n  queries,\n}: CreateContractTablesOptions<config, extraTableDefs>) => {\n  return mapObject(tableDefs, (def) => {\n    if (Object.keys(def.valueSchema).length === 0) throw new Error(\"Schema definition must have at least one key\");\n\n    const metadata = createMetadata(def);\n    const methods = createTableMethods({\n      store,\n      queries,\n      metadata: {\n        ...def,\n        schema: metadata.schema,\n        keySchema: metadata.metadata.keySchema,\n        propertiesSchema: metadata.metadata.propertiesSchema,\n      },\n    });\n\n    // Store properties schema in TinyBase for easier access in the storage adapter\n    storePropertiesSchema(store, def.tableId, metadata.metadata.propertiesSchema);\n\n    return {\n      ...metadata,\n      ...methods,\n    };\n  }) as unknown as ContractTables<typeof tableDefs>;\n};\n","import { type ContractTableDef, Type, schemaAbiTypeToRecsType } from \"@/lib\";\n\n/**\n * Creates and formats the metadata for a contract table.\n *\n * Note: This will convert the \"valueSchema\" key, as defined in MUD, into a \"propertiesSchema\" key.\n *\n * @param def The contract table definition.\n * @returns The relevant metadata for the contract table.\n * @category Tables\n * @internal\n */\nexport const createMetadata = <tableDef extends ContractTableDef>(def: tableDef) => {\n  const schema = {\n    ...Object.fromEntries(\n      Object.entries(def.valueSchema).map(([fieldName, { type: schemaAbiType }]) => [\n        fieldName,\n        schemaAbiTypeToRecsType[schemaAbiType],\n      ]),\n    ),\n    __staticData: Type.OptionalHex,\n    __encodedLengths: Type.OptionalHex,\n    __dynamicData: Type.OptionalHex,\n    __lastSyncedAtBlock: Type.OptionalBigInt,\n  } as const;\n\n  return {\n    id: def.tableId,\n    schema,\n    metadata: {\n      name: def.name,\n      globalName: `${def.namespace}__${def.name}`,\n      keySchema: Object.fromEntries(\n        Object.entries(def.keySchema).map(([fieldName, schemaAbiType]) => [fieldName, schemaAbiType[\"type\"]]),\n      ),\n      propertiesSchema: Object.fromEntries(\n        Object.entries(def.valueSchema).map(([fieldName, schemaAbiType]) => [fieldName, schemaAbiType[\"type\"]]),\n      ),\n    },\n  };\n};\n","import type { AbiToKeySchema, ContractTableMethods, ContractTableWithKeysMethods, KeySchema } from \"@/tables/contract\";\nimport type { Properties, PropertiesSansMetadata, OriginalTableMethods } from \"@/tables\";\nimport { decode$Record, encode$Record, default$Record, type $Record, type Schema } from \"@/lib\";\n\n/**\n * Create a set of methods to interact with a contract table using values for its keys properties,\n * that get encoded into a $Record.\n *\n * Note: See {@link ContractTableWithKeysMethods} for more information about each method.\n *\n * @param keySchema The schema of the keys properties.\n * @param methods The original table methods (see {@link ContractTableMethods}).\n * @returns The key-specific table methods (see {@link ContractTableWithKeysMethods}).\n * @category Table\n */\nexport const createTableKeyMethods = <\n  PS extends Schema,\n  TKeySchema extends KeySchema,\n  KS extends AbiToKeySchema<TKeySchema>,\n  T = unknown,\n>({\n  keySchema,\n  ...methods\n}: { keySchema: TKeySchema } & ContractTableMethods<PS, T> & OriginalTableMethods): ContractTableWithKeysMethods<\n  PS,\n  KS,\n  T\n> => {\n  const { get, has, use, set } = methods;\n\n  // Get the properties of a record using its keys\n  function getWithKeys(): Properties<PS, T> | undefined;\n  function getWithKeys(keys?: Properties<KS, T>): Properties<PS, T> | undefined;\n  function getWithKeys(keys?: Properties<KS, T>, defaultProperties?: PropertiesSansMetadata<PS, T>): Properties<PS, T>;\n  function getWithKeys(keys?: Properties<KS, T>, defaultProperties?: PropertiesSansMetadata<PS, T>) {\n    const $record = keys ? encode$Record(keySchema, keys) : default$Record;\n    return get($record, defaultProperties);\n  }\n\n  // Check if a record exists inside the table using its keys\n  const hasWithKeys = (keys?: Properties<KS, T>) => {\n    const $record = keys ? encode$Record(keySchema, keys) : default$Record;\n    return has($record);\n  };\n\n  // Use (hook) the properties of a record using its keys\n  const useWithKeys = (keys?: Properties<KS, T>, defaultProperties?: PropertiesSansMetadata<PS, T>) => {\n    const $record = keys ? encode$Record(keySchema, keys) : default$Record;\n    return use($record, defaultProperties);\n  };\n\n  // Set the properties of a record using its keys\n  const setWithKeys = (properties: Properties<PS, T>, keys: Properties<KS, T>) => {\n    const $record = keys ? encode$Record(keySchema, keys) : default$Record;\n    return set(properties, $record);\n  };\n\n  // Get the keys properties of a record using its record\n  const get$RecordKeys = ($record: $Record) => {\n    return decode$Record(keySchema, $record) as unknown as Properties<KS, T>;\n  };\n\n  return {\n    getWithKeys,\n    hasWithKeys,\n    // Don't expose useWithKeys in a non-browser environment\n    useWithKeys:\n      typeof window !== \"undefined\"\n        ? useWithKeys\n        : () => {\n            throw new Error(\"The method useWithKeys is only available in the browser\");\n          },\n    setWithKeys,\n    get$RecordKeys,\n  };\n};\n","import { keccak256, toHex } from \"viem\";\n\nimport type { LocalTable, LocalTableMetadata } from \"@/tables/local\";\nimport { createTableMethods, type Properties } from \"@/tables\";\nimport { type Metadata, type Schema, type Store, Type, uuid } from \"@/lib\";\n\n/**\n * Defines the options for creating a local table.\n *\n * @template M The type of any provided metadata for the table.\n * @param id The unique identifier for the table, usually—but not necessarily— a human-readable and descriptive name.\n * @param metadata (optional) Any additional metadata to be associated with the table.\n * @param persist (optional) Whether the table should be persisted in local storage or not. Default: false.\n */\nexport type CreateLocalTableOptions<M extends Metadata> = {\n  id: string; // default: uuid\n  metadata?: M;\n  persist?: boolean;\n};\n\n/**\n * Creates a local table with the specified schema, options and default properties.\n *\n * These tables are meant to be created directly during implementation, then used alongside contract tables\n * the exact same way. The only difference is that they won't take any key for accessing various records, as\n * they are designed as a single record table.\n *\n * Note: when creating a persistent table, on the browser, you MUST wait for the sync with local storage to be started;\n * otherwise, there will be inconsistencies with properties from the last and current sessions.\n *\n * @param store The store accessor returned by the wrapper, containing both the persistent and regular stores.\n * @param schema The schema of the table, defining the properties and their types.\n * @param options (optional) The options for creating the table (see {@link CreateLocalTableOptions}).\n * @param defaultProperties (optional) The default properties to set for the table on initialization; will be overridden\n * if the table is persistent and already has properties from a previous session\n * @returns A local table object with the specified properties, and fully typed methods for data manipulation.\n * @example\n * This example creates a local table with a single property, \"darkMode\", set to false.\n *\n * ```ts\n * const darkModeTable = createLocalTable(store, { darkMode: PropType.Boolean }, { id: \"DarkMode\" }, { darkMode: false });\n * console.log(darkModeTable.get());\n * // -> { darkMode: false }\n *\n * // or more simply\n * const darkModeTable = createLocalBoolTable(store, { id: \"DarkMode\" }, { value: false });\n * console.log(darkModeTable.get());\n * // -> { value: false }\n * ```\n *\n * @example\n * This example creates a persistent local table with coordinates properties.\n *\n * ```ts\n * // Wait for the sync with local storage to be started after creating the wrapper\n * const { store } = createWrapper({ mudConfig });\n * await store(\"PERSIST\").ready();\n *\n * // This table will be persisted in local storage, and loaded with its latest properties next time.\n * const coordsTable = createLocalCoordTable(store, { id: \"Coords\", persist: true }, { x: 0, y: 0 });\n * ```\n * @category Creation\n */\nexport const createLocalTable = <S extends Schema, M extends Metadata, T = unknown>(\n  store: Store,\n  schema: S,\n  options?: CreateLocalTableOptions<M>,\n  defaultProperties?: Properties<S, T>,\n): LocalTable<S, M, LocalTableMetadata<S, M>, T> => {\n  const { id } = options ?? { id: uuid() };\n  // Get the appropriate store instance\n  const storeInstance = options?.persist ? store(\"PERSIST\") : store();\n\n  // Format metadata the same way as MUD tables to treat it the same way during methods creation\n  const metadata = {\n    tableId: keccak256(toHex(id)),\n    namespace: \"internal\" as const,\n    name: id,\n    schema,\n  } as LocalTableMetadata<S, M>;\n\n  const table = {\n    // Table data\n    id: metadata.tableId,\n    schema,\n    metadata: {\n      ...options?.metadata,\n      name: id,\n      globalName: `internal__${id}`,\n    },\n    // Methods\n    ...createTableMethods({ store: storeInstance, queries: storeInstance.getQueries(), metadata }),\n  } as unknown as LocalTable<S, M, typeof metadata, T>;\n\n  // If some default properties are provided\n  if (defaultProperties) {\n    // and the table is persistent, check if the properties were already stored last time\n    const properties = options?.persist ? table.get() : undefined;\n    // If not, or if the table is not persistent, set the default properties\n    if (properties === undefined) {\n      table.set(defaultProperties);\n    }\n  }\n\n  return table;\n};\n\n/**\n * Defines a local table with a single number property.\n */\nexport type LocalNumberTable = ReturnType<typeof createLocalNumberTable>;\n/**\n * Creates a local table with the specified schema, options and default properties.\n *\n * This is a shorthand for creating a local table with a single number property.\n * @see {@link createLocalTable}\n */\nexport const createLocalNumberTable = <M extends Metadata>(\n  store: Store,\n  options?: CreateLocalTableOptions<M>,\n  defaultProperties?: Properties<{ value: Type.Number }>,\n) => {\n  return createLocalTable(store, { value: Type.Number }, options, defaultProperties);\n};\n\n/**\n * Defines a local table with a single BigInt property.\n */\nexport type LocalBigIntTable = ReturnType<typeof createLocalBigIntTable>;\n/**\n * Creates a local table with the specified schema, options and default properties.\n *\n * This is a shorthand for creating a local table with a single BigInt property.\n * @see {@link createLocalTable}\n */\nexport const createLocalBigIntTable = <M extends Metadata>(\n  store: Store,\n  options?: CreateLocalTableOptions<M>,\n  defaultProperties?: Properties<{ value: Type.BigInt }>,\n) => {\n  return createLocalTable(store, { value: Type.BigInt }, options, defaultProperties);\n};\n\n/**\n * Defines a local table with a single string property.\n */\nexport type LocalStringTable = ReturnType<typeof createLocalStringTable>;\n/**\n * Creates a local table with the specified schema, options and default properties.\n *\n * This is a shorthand for creating a local table with a single string property.\n * @see {@link createLocalTable}\n */\nexport const createLocalStringTable = <M extends Metadata>(\n  store: Store,\n  options?: CreateLocalTableOptions<M>,\n  defaultProperties?: Properties<{ value: Type.String }>,\n) => {\n  return createLocalTable(store, { value: Type.String }, options, defaultProperties);\n};\n\n/**\n * Defines a local table with number properties for coordinates, specifically `x` and `y`.\n */\nexport type LocalCoordTable = ReturnType<typeof createLocalCoordTable>;\n/**\n * Creates a local table with the specified schema, options and default properties.\n *\n * This is a shorthand for creating a local table with number properties for coordinates, specifically `x` and `y`.\n * @see {@link createLocalTable}\n */\nexport const createLocalCoordTable = <M extends Metadata>(\n  store: Store,\n  options?: CreateLocalTableOptions<M>,\n  defaultProperties?: Properties<{ x: Type.Number; y: Type.Number }>,\n) => {\n  return createLocalTable(store, { x: Type.Number, y: Type.Number }, options, defaultProperties);\n};\n\n/**\n * Defines a local table with a single boolean property.\n */\nexport type LocalBoolTable = ReturnType<typeof createLocalBoolTable>;\n/**\n * Creates a local table with the specified schema, options and default properties.\n *\n * This is a shorthand for creating a local table with a single boolean property.\n * @see {@link createLocalTable}\n */\nexport const createLocalBoolTable = <M extends Metadata>(\n  store: Store,\n  options?: CreateLocalTableOptions<M>,\n  defaultProperties?: Properties<{ value: Type.Boolean }>,\n) => {\n  return createLocalTable(store, { value: Type.Boolean }, options, defaultProperties);\n};\n\n/**\n * Defines a local table with a single record property.\n */\nexport type Local$RecordTable = ReturnType<typeof createLocal$RecordTable>;\n/**\n * Creates a local table with the specified schema, options and default properties.\n *\n * This is a shorthand for creating a local table with a single record property.\n * @see {@link createLocalTable}\n */\nexport const createLocal$RecordTable = <M extends Metadata>(\n  store: Store,\n  options?: CreateLocalTableOptions<M>,\n  defaultProperties?: Properties<{ value: Type.$Record }>,\n) => {\n  return createLocalTable(store, { value: Type.$Record }, options, defaultProperties);\n};\n"],"mappings":"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","names":["storeToV1","resolveConfig","useEffect","useState","queryAllWithProperties","queries","tableId","properties","formattedProperties","queryId","TinyBaseAdapter","select","where","key","$records","rowId","queryAllWithoutProperties","queries","tableId","properties","formattedProperties","queryId","TinyBaseAdapter","select","where","getCell","key","$records","rowId","useEffect","useMemo","useState","useAllWithProperties","queries","tableId","properties","formattedProperties","useMemo","TinyBaseAdapter","$records","set$Records","useState","useEffect","id","queryAllWithProperties","listenerId","useEffect","useMemo","useState","useAllWithoutProperties","queries","tableId","properties","formattedProperties","useMemo","TinyBaseAdapter","$records","set$Records","useState","useEffect","id","queryAllWithoutProperties","listenerId","createTableWatcher","options","params","queries","query","tableId","schema","onChange","onEnter","onExit","onUpdate","queryId","uuid","createTableTinyQLWatcher","store","keys","listenerId","_","__","rowId","getCellChange","args","getPropertiesAndTypeFromRowChange","rows","rowContent","currentProperties","TinyBaseAdapter","createTableTinyQLWatcher","options","params","queries","queryId","tableId","schema","onChange","onEnter","onExit","onUpdate","store","keys","previous$Records","listenerId","_","__","rowId","getCellChange","$record","matching$Records","type","inPrev","inCurrent","args","getPropertiesAndTypeFromRowChange","e","rows","currentProperties","TinyBaseAdapter","createQueries","query","_store","options","inside","notInside","withProperties","withoutProperties","store","queries","createQueries","$records","acc","table","index","$record","properties","i","queryId","$recordsWithProperties","queryAllWithProperties","$query","_store","queryOptions","callbacks","params","onChange","onEnter","onExit","onUpdate","store","prev$Records","tables","inside","notInside","withProperties","withoutProperties","table","listenerId","_","tableId","rowId","getCellChange","$record","matching$Records","query","type","inPrev","inCurrent","args","getPropertiesAndTypeFromRowChange","e","useEffect","useMemo","useRef","useState","useQuery","_store","options","callbacks","onChange","onEnter","onExit","onUpdate","store","$records","set$Records","useState","prev$Records","useRef","tables","useMemo","inside","notInside","withProperties","withoutProperties","table","useEffect","curr$Records","query","listenerId","_","tableId","$recordKey","getCellChange","$record","new$Records","type","inPrev","inCurrent","args","getPropertiesAndTypeFromRowChange","inContractTableMetadata","metadata","createTableMethods","store","queries","tableId","schema","paused","createTableMethodsUtils","$records","arrayToIterator","pauseUpdates","$record","properties","default$Record","set","resumeUpdates","formattedProperties","TinyBaseAdapter","setRaw","get","defaultProperties","row","getRaw","getAll","getAllWith","queryAllWithProperties","getAllWithout","queryAllWithoutProperties","useAll","set$Records","useState","useEffect","subId","useAllWith","useAllWithProperties","useAllWithout","useAllWithoutProperties","clear","remove","update","currentProperties","newProperties","has","useProperties","setProperties","propertiesSubId","pausedSubId","_","__","newPaused","baseMethods","definition","abstractedQuery","keywords","queryId","uuid","result","options","params","query","createTableWatcher","hookMethods","key","methods","createTableKeyMethods","createRegistry","tableDefs","store","queries","mapObject","def","metadata","createMetadata","methods","createTableMethods","storePropertiesSchema","createMetadata","def","schema","fieldName","schemaAbiType","schemaAbiTypeToRecsType","createTableKeyMethods","keySchema","methods","get","has","use","set","getWithKeys","keys","defaultProperties","$record","encode$Record","default$Record","properties","decode$Record","createWrapper","mudConfig","otherTableDefs","tableDefs","resolveConfig","storeToV1","storeTableDefs","worldTableDefs","store","createStore","registry","createRegistry","storageAdapter","createCustomWriter","keccak256","toHex","createLocalTable","store","schema","options","defaultProperties","id","uuid","storeInstance","metadata","keccak256","toHex","table","createTableMethods","createLocalNumberTable","createLocalBigIntTable","createLocalStringTable","createLocalCoordTable","createLocalBoolTable","createLocal$RecordTable"]}