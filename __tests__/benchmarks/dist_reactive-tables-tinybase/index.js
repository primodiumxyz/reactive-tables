import{a as N,b as F,c as H,d as k,e as V,g as z,h as O,i as G,j as ue,k as me,l as J,m as X,n as w,q as Q,r as Y,s as Z,t as ee,u as g}from"./chunk-Q2PQUU6M.js";import{storeToV1 as De}from"@latticexyz/store/config/v2";import{resolveConfig as We}from"@latticexyz/store/internal";import{useEffect as se,useState as ne}from"react";var K=({queries:e,tableId:a,properties:t,formattedProperties:r})=>{let s="internal__queryAllWithProperties";r=r??g.encode(t),e.setQueryDefinition(s,a,({select:i,where:c})=>{i(Object.keys(t)[0]),Object.keys(t).forEach(d=>{c(d,r[d])})});let n=[];return e.forEachResultRow(s,i=>n.push(i)),{id:s,$records:n}};var U=({queries:e,tableId:a,properties:t,formattedProperties:r})=>{let s="internal__queryAllWithoutProperties";r=r??g.encode(t),e.setQueryDefinition(s,a,({select:i,where:c})=>{i(Object.keys(t)[0]),c(d=>Object.keys(t).some(u=>d(u)!==r[u]))});let n=[];return e.forEachResultRow(s,i=>n.push(i)),{id:s,$records:n}};import{useEffect as Te,useMemo as ye,useState as fe}from"react";var te=(e,a,t)=>{let r=ye(()=>g.encode(t),[t]),[s,n]=fe([]);return Te(()=>{let{id:i,$records:c}=K({queries:e,tableId:a,properties:t,formattedProperties:r});n(c);let d=e.addResultRowIdsListener(i,()=>{n(e.getResultRowIds(i))});return()=>{e.delListener(d)}},[e,r]),s};import{useEffect as be,useMemo as he,useState as Se}from"react";var re=(e,a,t)=>{let r=he(()=>g.encode(t),[t]),[s,n]=Se([]);return be(()=>{let{id:i,$records:c}=U({queries:e,tableId:a,properties:t,formattedProperties:r});n(c);let d=e.addResultRowIdsListener(i,()=>{n(e.getResultRowIds(i))});return()=>{e.delListener(d)}},[e,r]),s};var oe=(e,a={runOnInit:!0})=>{let{queries:t,query:r,tableId:s,schema:n,onChange:i,onEnter:c,onExit:d,onUpdate:u}=e;if(r){let T=k();return t.setQueryDefinition(T,s,r),ae({queries:t,queryId:T,tableId:s,schema:n,onChange:i,onEnter:c,onExit:d},a)}if(!i&&!c&&!d&&!u)throw new Error("At least one callback has to be provided");let f=t.getStore(),p=Object.keys(n),l=f.addRowListener(s,null,(T,x,P,b)=>{if(!b)return;let h=O(b,p,s,P);h.type==="enter"?c?.(h):h.type==="exit"?d?.(h):u?.(h),i?.(h)});if(a.runOnInit){let T=f.getTable(s);Object.entries(T).forEach(([x,P])=>{let b=g.decode(P),y={tableId:s,$record:x,properties:{current:b,prev:void 0},type:"enter"};c?.(y),i?.(y)})}return{unsubscribe:()=>f.delListener(l)}};var ae=(e,a={runOnInit:!0})=>{let{queries:t,queryId:r,tableId:s,schema:n,onChange:i,onEnter:c,onExit:d,onUpdate:u}=e;if(!i&&!c&&!d&&!u)throw new Error("At least one callback has to be provided");let f=t.getStore(),p=Object.keys(n),l=[],T=f.addRowListener(s,null,(x,P,b,y)=>{if(!y)return;let h=b,D=t.getResultRowIds(r),S="change",W=l.includes(h),$=D.includes(h);if(!W&&!$)return;let M=O(y,p,s,h);!W&&$?(S="enter",c?.({...M,type:S}),l.push(h)):W&&!$?(S="exit",d?.({...M,type:S}),l=l.filter(L=>L!==h)):u?.({...M,type:S}),i?.({...M,type:S})});if(a.runOnInit){let x=f.getTable(s);t.forEachResultRow(r,P=>{let b=g.decode(x[P]),y={tableId:s,$record:P,properties:{current:b,prev:void 0},type:"enter"};c?.(y),i?.(y),l.push(P)})}return{unsubscribe:()=>t.delListener(T)}};import{createQueries as Pe}from"tinybase/queries";var A=(e,a)=>{let{with:t,without:r,withProperties:s,withoutProperties:n}=a;if(!t&&!s)throw new Error("At least one inside or with condition needs to be provided");let i=e(),c=Pe(i),d=t?t.reduce((u,f,p)=>f.getAll().filter(l=>p!==0?u.includes(l):!0),[]):[];return s?.forEach(({table:u,properties:f},p)=>{let{id:l,$records:T}=K({queries:c,tableId:u.id,properties:f});if(t===void 0&&p===0){d=T,p===s.length-1&&c.delQueryDefinition(l);return}d=T.filter(x=>d.includes(x)),p===s.length-1&&c.delQueryDefinition(l)}),r?.forEach(u=>{d=d.filter(f=>!u.has(f))}),n?.forEach(({table:u,properties:f},p)=>{let{id:l,$records:T}=K({queries:c,tableId:u.id,properties:f});d=d.filter(x=>!T.includes(x)),p===n.length-1&&c.delQueryDefinition(l)}),d};var Re=(e,a,t,r={runOnInit:!0})=>{let{onChange:s,onEnter:n,onExit:i,onUpdate:c}=t;if(!s&&!n&&!i&&!c)throw new Error("At least one callback has to be provided");let d=e(),u=[],f={},{with:p,without:l,withProperties:T,withoutProperties:x}=a;(p??[]).concat(l??[]).forEach(b=>{f[b.id]=Object.keys(b.schema)}),(T??[]).concat(x??[]).forEach(({table:b})=>{f[b.id]=Object.keys(b.schema)});let P=d.addRowListener(null,null,(b,y,h,D)=>{if(!D)return;let S=h;if(Object.keys(f).includes(y)){let W=A(e,a),$="change",M=u.includes(S),L=W.includes(S);if(!M&&!L)return;let I=O(D,f[y],y,S);!M&&L?($="enter",n?.({...I,type:$}),u.push(S)):M&&!L?($="exit",i?.({...I,type:$}),u=u.filter(B=>B!==S)):c?.({...I,type:$}),s?.({...I,type:$})}});return r.runOnInit&&A(e,a).forEach(y=>{let h={tableId:void 0,$record:y,properties:{current:void 0,prev:void 0},type:"enter"};n?.(h),s?.(h),u.push(y)}),{unsubscribe:()=>d.delListener(P)}};import{useEffect as xe,useMemo as ge,useRef as $e,useState as Me}from"react";var we=(e,a,t)=>{if(typeof window>"u")throw new Error("useQuery is only available in a browser environment");let{onChange:r,onEnter:s,onExit:n,onUpdate:i}=t??{},c=e(),[d,u]=Me([]),f=$e([]),p=ge(()=>{let{with:l,without:T,withProperties:x,withoutProperties:P}=a,b={};return(l??[]).concat(T??[]).forEach(y=>{b[y.id]=Object.keys(y.schema)}),(x??[]).concat(P??[]).forEach(({table:y})=>{b[y.id]=Object.keys(y.schema)}),b},[a]);return xe(()=>{let l=A(e,a);u(l),f.current=l;let T=c.addRowListener(null,null,(x,P,b,y)=>{if(!y)return;let h=b;if(Object.keys(p).includes(P)){let D=A(e,a),S="change",W=f.current.includes(h),$=D.includes(h),M=O(y,p[P],P,h);!W&&$?(S="enter",s?.({...M,type:S})):W&&!$?(S="exit",n?.({...M,type:S})):i?.({...M,type:S}),r?.({...M,type:S}),u(D),f.current=D}});return()=>{c.delListener(T)}},[]),d};var Ce=e=>"keySchema"in e,_=({store:e,queries:a,metadata:t})=>{let{tableId:r,schema:s}=t,{paused:n}=z(e,r),i=()=>Z(e.getRowIds(r)),c=(o,m)=>{o=o??w,n.set(o,!0),m&&u(m,o)},d=o=>{o=o??w,n.get(o)&&n.set(o,!1)},u=(o,m)=>{m=m??w;let R=g.encode(o);e.setRow(r,m,R)},f=(o,m)=>{m=m??w,e.setRow(r,m,o)};function p(o,m){o=o??w;let R=e.getRow(r,o);return(Object.entries(R).length>0?g.decode(R):void 0)??m}let l=o=>{let m=e.getRow(r,o);return Object.entries(m).length>0?m:void 0},T=()=>e.getRowIds(r),x=o=>K({queries:a,tableId:r,properties:o}).$records,P=o=>U({queries:a,tableId:r,properties:o}).$records;function b(){let[o,m]=ne(T());return se(()=>{let R=e.addRowIdsListener(r,()=>{m(T())});return()=>{e.delListener(R)}},[]),o}let y=o=>te(a,r,o),h=o=>re(a,r,o),D=()=>{e.delTable(r)},S=o=>{o=o??w,e.delRow(r,o)},W=(o,m)=>{m=m??w;let R=l(m);if(!R)throw new Error(`$Record ${m} does not exist in table ${r}`);let C=g.encode(o);f({...R,...C},m)},$=o=>o?e.hasRow(r,o):!1;function M(o,m){o=o??w;let[R,C]=ne(p(o));return se(()=>{n.get(o)||C(p(o));let E=e.addRowListener(r,o,()=>{n.get(o)||C(p(o))}),de=e.addValueListener(`paused__${r}__${o}`,(Ae,Le,le)=>{le||C(p(o))});return()=>{e.delListener(E),e.delListener(de)}},[o,n]),R??m}let B={$records:i,get:p,set:u,getAll:T,getAllWith:x,getAllWithout:P,remove:S,clear:D,update:W,has:$,pauseUpdates:c,resumeUpdates:d,query:o=>{let m=E=>{E.select(Object.keys(s)[0]),o(E)},R=k();a.setQueryDefinition(R,r,m);let C=a.getResultRowIds(R);return a.delQueryDefinition(R),C},watch:(o,m)=>{let R=o.query?C=>{C.select(Object.keys(s)[0]),o.query(C)}:void 0;return oe({queries:a,tableId:r,schema:s,...o,query:R},m)}},q={useAll:b,useAllWith:y,useAllWithout:h,use:M};typeof window>"u"&&Object.keys(q).forEach(o=>{q[o]=()=>{throw new Error(`The method ${o} is only available in the browser`)}});let j={...B,...q};return Ce(t)?{...j,...ie({...j,keySchema:t.keySchema})}:j};var ce=({tableDefs:e,store:a,queries:t})=>H(e,r=>{if(Object.keys(r.valueSchema).length===0)throw new Error("Schema definition must have at least one key");let s=pe(r),n=_({store:a,queries:t,metadata:{...r,schema:s.schema,keySchema:s.metadata.keySchema,propertiesSchema:s.metadata.propertiesSchema}});return V(a,r.tableId,s.metadata.propertiesSchema),{...s,...n}});var pe=e=>{let a={...Object.fromEntries(Object.entries(e.valueSchema).map(([t,{type:r}])=>[t,F[r]])),__staticData:14,__encodedLengths:14,__dynamicData:14,__lastSyncedAtBlock:4};return{id:e.tableId,schema:a,metadata:{name:e.name,globalName:`${e.namespace}__${e.name}`,keySchema:Object.fromEntries(Object.entries(e.keySchema).map(([t,r])=>[t,r.type])),propertiesSchema:Object.fromEntries(Object.entries(e.valueSchema).map(([t,r])=>[t,r.type]))}}};var ie=({keySchema:e,...a})=>{let{get:t,has:r,use:s,set:n}=a;function i(p,l){let T=p?Q(e,p):w;return t(T,l)}return{getWithKeys:i,hasWithKeys:p=>{let l=p?Q(e,p):w;return r(l)},useWithKeys:typeof window<"u"?(p,l)=>{let T=p?Q(e,p):w;return s(T,l)}:()=>{throw new Error("The method useWithKeys is only available in the browser")},setWithKeys:(p,l)=>{let T=l?Q(e,l):w;return n(p,T)},get$RecordKeys:p=>Y(e,p)}};var Gt=({mudConfig:e,otherTableDefs:a})=>{let t={...We(De(e)).tables,...a??{},...J,...X},r=G(),s=ce({tableDefs:t,store:r(),queries:r().getQueries()}),n=ee({store:r});return{registry:s,tableDefs:t,store:r,storageAdapter:n}};import{keccak256 as Oe,toHex as Ke}from"viem";var v=(e,a,t,r)=>{let{id:s}=t??{id:k()},n=t?.persist?e("PERSIST"):e(),i={tableId:Oe(Ke(s)),namespace:"internal",name:s,schema:a},c={id:i.tableId,schema:a,metadata:{...t?.metadata,name:s,globalName:`internal__${s}`},..._({store:n,queries:n.getQueries(),metadata:i})};return r&&(t?.persist?c.get():void 0)===void 0&&c.set(r),c},er=(e,a,t)=>v(e,{value:1},a,t),tr=(e,a,t)=>v(e,{value:3},a,t),rr=(e,a,t)=>v(e,{value:5},a,t),or=(e,a,t)=>v(e,{x:1,y:1},a,t),ar=(e,a,t)=>v(e,{value:0},a,t),sr=(e,a,t)=>v(e,{value:17},a,t);export{Re as $query,N as PropType,sr as createLocal$RecordTable,tr as createLocalBigIntTable,ar as createLocalBoolTable,or as createLocalCoordTable,er as createLocalNumberTable,rr as createLocalStringTable,v as createLocalTable,Gt as createWrapper,w as default$Record,me as localProperties,ue as metadataProperties,A as query,we as useQuery};
//# sourceMappingURL=index.js.map