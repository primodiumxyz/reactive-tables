import { Subject } from "rxjs";

import { createTableMethods } from "@/tables/methods/createTableMethods";
import type { BaseTable, Table } from "@/tables/types";
import { type EntitySymbol, getEntityHex } from "@/lib/external/mud/entity";
import { createIndexer } from "@/lib/external/mud/indexer";
import type { BaseTableMetadata, Schema } from "@/lib/external/mud/schema";
import { mapObject, transformIterator } from "@/lib/external/mud/utils";
import type { World } from "@/lib/external/mud/world";
import { uuid } from "@/lib/external/uuid";
import { createLocalStorageAdapter, DEFAULT_VERSION, type PersistentStorageAdapter } from "@/lib/persistence";

/**
 * Defines the options for creating a table (especially useful for local tables).
 *
 * @template PS The schema of the properties for all entities inside the table.
 * @template M The type of any provided metadata for the table.
 * @template T The type of the properties to match.
 * @param id The unique identifier for the table, usually—but not necessarily— a human-readable and descriptive name.
 * @param metadata (optional) Any additional metadata to be associated with the table.
 * @param indexed (optional) Whether the table should be indexed or not. Default: false.
 * @param persist (optional) Whether the table should be persisted in local storage or not. Default: false.
 * @param version (optional) The version of the table, to use along persistence; when changed, it will reset properties for all entities (reset local storage state of the table).
 * Default: "0.0.0".
 * @param storageAdapter (optional) The storage adapter to use for persistence. Default: {@link createLocalStorageAdapter}.
 */
export type TableOptions<M extends BaseTableMetadata = BaseTableMetadata, P extends boolean = false> = {
  id: string; // default: uuid
  metadata?: M;
  indexed?: boolean;
  persist?: P;
  version?: string;
  storageAdapter?: PersistentStorageAdapter;
};

/**
 * Tables contain state indexed by entities.
 * Besides containing the state, components expose an rxjs update$ stream, that emits an event any time the value
 * of an entity in this table is updated.
 *
 * Note: This is modified from RECS.
 *
 * @param world {@link World} object this table should be registered onto.
 * @param propertiesSchema {@link Schema} of table properties (values). Uses Type enum as bridge between Typescript types and Javascript accessible values.
 * @param options Optional {@link TableOptions} with the following properties:
 * - `id` A descriptive id for this component (otherwise an autogenerated id is used)
 * - `metadata` Arbitrary metadata
 * - `indexed` If this flag is set, an indexer is applied to this component (see {@link createIndexer})
 * - `persist` If this flag is set, the table is persisted in local storage
 * - `version` The version of the table, to use along persistence; when changed, it will reset properties for all entities (reset local storage state of the table)
 * - `storageAdapter` A storage adapter to use for reading/writing persisted data
 * @returns Table object linked to the provided World
 * @category Tables
 * @internal
 */
export const createTable = <PS extends Schema, M extends BaseTableMetadata, P extends boolean, T = unknown>(
  world: World,
  propertiesSchema: PS,
  options?: TableOptions<M, P>,
) => {
  if (Object.keys(propertiesSchema).length === 0) throw new Error("Table properties schema must have at least one key");
  const id = options?.id ?? uuid();
  const baseMetadata = options?.metadata ?? {};
  const indexed = options?.indexed ?? false;
  const persist = options?.persist ?? false;
  const version = options?.version ?? DEFAULT_VERSION;
  const storageAdapter = options?.storageAdapter ?? createLocalStorageAdapter();

  if (persist && typeof window === "undefined")
    throw new Error("Tables cannot be persisted in a non-browser environment");
  if (persist && !options?.id) throw new Error("You must provide an id for a table to be persisted");

  // Metadata
  const metadata = {
    ...baseMetadata,
    name: options?.metadata?.name ?? id,
    namespace: options?.metadata?.namespace ?? "",
    globalName: options?.metadata?.globalName ?? id,
  } as const satisfies BaseTableMetadata;

  // Create a new properties mapping or retrieve the last state from local storage
  const persistedProperties = persist ? storageAdapter.getAllProperties(id, propertiesSchema, version) : undefined;
  const properties = (persistedProperties ?? mapObject(propertiesSchema, () => new Map())) as BaseTable<
    PS,
    typeof metadata,
    T
  >["properties"];

  // Update stream
  const update$ = new Subject() as BaseTable<PS, typeof metadata, T>["update$"];
  // Native RECS entities iterator
  const entities = () =>
    transformIterator((Object.values(properties)[0] as Map<EntitySymbol, unknown>).keys(), getEntityHex);

  const baseTable = {
    id,
    properties,
    propertiesSchema,
    metadata,
    world,
    entities,
    update$,
  } as const satisfies BaseTable<PS, typeof metadata, T>;

  const table = {
    ...baseTable,
    ...createTableMethods<PS, typeof metadata, T>(world, baseTable, storageAdapter, persist, version),
  };

  world.registerTable(table);
  if (indexed) return createIndexer(table);
  return table as Table<PS, typeof metadata, T>;
};
